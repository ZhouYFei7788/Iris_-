################################################此版本为重构一版###########################################################
################################################此版本为重构一版###########################################################
################################################此版本为重构一版###########################################################
################################################此版本为重构一版###########################################################
"""此版本为重构一版"""
# import cx_Oracle
# import pandas as pd
# import matplotlib.pyplot as plt
# from matplotlib import rcParams
# # 数据库连接信息
# dsn = cx_Oracle.makedsn("localhost", 1521, service_name="XE")  # 替换为你的数据库信息
# #连接数据库
# connection = cx_Oracle.connect(user="C##YUANWEIHUA", password="root", dsn=dsn)
# # # 创建数据表 导入表
# # create_table_sql = """
# # CREATE TABLE "模型训练日志" (
# #     "编号" NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- 自增ID
# #     "轮次" NUMBER NOT NULL,                                    -- 训练轮次
# #     "模型名称" VARCHAR2(50) NOT NULL,                         -- 模型名称
# #     "交叉验证分组" NUMBER,                                     -- 交叉验证的分组编号
# #     "训练集准确率" FLOAT,                                      -- 训练集的准确率
# #     "验证集准确率" FLOAT,                                      -- 验证集的准确率
# #     "训练集损失值" FLOAT,                                      -- 训练集的损失值
# #     "验证集损失值" FLOAT,                                      -- 验证集的损失值
# #     "精确率" FLOAT,                                           -- 精确率
# #     "召回率" FLOAT,                                           -- 召回率
# #     "F1值" FLOAT,                                             -- F1值
# #     "混淆矩阵" CLOB,                                           -- 混淆矩阵（可以存储为 CLOB 类型）
# #     "AUC" FLOAT,                                              -- AUC值
# #     "创建时间" TIMESTAMP DEFAULT CURRENT_TIMESTAMP            -- 创建时间
# # )
# # """
# # try:
# #     with connection.cursor() as cursor:
# #         cursor.execute(create_table_sql)
# #     print("表创建成功！")
# # except cx_Oracle.DatabaseError as e:
# #     print("表已存在或其他错误：", e)
#
#
# # 插入模拟数据
# insert_sql = """
# INSERT INTO "模型训练日志" ("轮次", "模型名称", "交叉验证分组", "训练集准确率", "验证集准确率",
# "训练集损失值", "验证集损失值", "精确率", "召回率", "F1值", "混淆矩阵", "AUC")
# VALUES (:轮次, :模型名称, :交叉验证分组, :训练集准确率, :验证集准确率,
# :训练集损失值, :验证集损失值, :精确率, :召回率, :F1值, :混淆矩阵, :AUC)
# """
#
# rcParams['font.sans-serif'] = ['SimHei']  # 使用黑体
# rcParams['axes.unicode_minus'] = False    # 解决负号显示问题
#
# # 模拟模型训练结果
# data = [
#     (1, "随机森林", 1, 0.95, 0.92, 0.05, 0.08, 0.93, 0.91, 0.92, '{"TP":50,"FP":5}', 0.98),
#     (2, "逻辑回归", 2, 0.89, 0.87, 0.11, 0.13, 0.88, 0.86, 0.87, '{"TP":45,"FP":8}', 0.95)
# ]
#
# with connection.cursor() as cursor:
#     for row in data:
#         cursor.execute(insert_sql, {
#             "轮次": row[0],
#             "模型名称": row[1],
#             "交叉验证分组": row[2],
#             "训练集准确率": row[3],
#             "验证集准确率": row[4],
#             "训练集损失值": row[5],
#             "验证集损失值": row[6],
#             "精确率": row[7],
#             "召回率": row[8],
#             "F1值": row[9],
#             "混淆矩阵": row[10],
#             "AUC": row[11]
#         })
# connection.commit()
# print("数据插入成功！")
#
# # 从数据库读取数据
# # read_sql = "SELECT * FROM \"模型训练日志\""
# # df = pd.read_sql(read_sql, con=connection)
#
# # # 展示数据
# # print(df)
# #
# # # 可视化 AUC 值
# # plt.figure(figsize=(10, 6))
# # plt.bar(df["模型名称"], df["AUC"], color='skyblue')
# # plt.title("模型 AUC 值对比")
# # plt.xlabel("模型名称")
# # plt.ylabel("AUC 值")
# # plt.show()
#
# connection.close()
########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################
"""此版本为重构二版启用"""

import numpy as np
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_score
from sklearn.metrics import confusion_matrix, roc_auc_score, precision_score, recall_score, f1_score
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, GradientBoostingClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.tree import DecisionTreeClassifier
from sklearn.cluster import KMeans
import cx_Oracle

# 连接数据库
connection = cx_Oracle.connect("C##YUANWEIHUA", "root", "localhost/XE")
cursor = connection.cursor()

# 鸢尾花数据集加载
data = load_iris()
X = data.data
y = data.target

# 分割数据集为训练集和验证集
X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# 定义模型列表
models = {
    "KNN": KNeighborsClassifier(),
    "逻辑回归": LogisticRegression(max_iter=200),
    "SVM": SVC(probability=True),
    "k-means聚类算法": KMeans(n_clusters=3),
    "朴素贝叶斯": GaussianNB(),
    "决策树": DecisionTreeClassifier(),
    "随机森林": RandomForestClassifier(random_state=42),
    "AdaBoost": AdaBoostClassifier(random_state=42),
    "梯度推动": GradientBoostingClassifier(random_state=42)
}

# 交叉验证设置
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

for model_name, model in models.items():
    if model_name == "k-means聚类算法":
        # 特殊处理：k-means为无监督学习，不需要y_train
        model.fit(X_train)
        train_accuracy = model.score(X_train, y_train)
        val_accuracy = model.score(X_val, y_val)
        precision, recall, f1, auc = None, None, None, None
        conf_matrix = None
        train_loss = None
        val_loss = None
    else:
        # 训练模型
        model.fit(X_train, y_train)

        # 计算训练集指标
        train_accuracy = model.score(X_train, y_train)
        y_train_pred = model.predict(X_train)
        train_loss = np.mean((y_train != y_train_pred).astype(float))

        # 计算验证集指标
        val_accuracy = model.score(X_val, y_val)
        y_val_pred = model.predict(X_val)
        val_loss = np.mean((y_val != y_val_pred).astype(float))
        precision = precision_score(y_val, y_val_pred, average='weighted')
        recall = recall_score(y_val, y_val_pred, average='weighted')
        f1 = f1_score(y_val, y_val_pred, average='weighted')

        # 混淆矩阵和AUC
        conf_matrix = confusion_matrix(y_val, y_val_pred)
        if hasattr(model, "predict_proba"):
            y_val_prob = model.predict_proba(X_val)
            auc = roc_auc_score(y_val, y_val_prob, multi_class='ovr')
        else:
            auc = None



    # # 插入数据库的SQL语句
    # insert_sql = """
    # INSERT INTO "模型训练日志" ("轮次", "模型名称", "交叉验证分组", "训练集准确率", "验证集准确率",
    # "训练集损失值", "验证集损失值", "精确率", "召回率", "F1值", "混淆矩阵", "AUC")
    # VALUES (:轮次, :模型名称, :交叉验证分组, :训练集准确率, :验证集准确率,
    # :训练集损失值, :验证集损失值, :精确率, :召回率, :F1值, :混淆矩阵, :AUC)
    # """
    # 插入数据库的SQL语句
    insert_sql = """
    INSERT INTO "模型训练日志" ("轮次", "模型名称", "交叉验证分组", "训练集准确率", "验证集准确率", 
    "训练集损失值", "验证集损失值", "精确率", "召回率", "F1值", "混淆矩阵", "AUC")
    VALUES
    (:轮次,:模型名称,:交叉验证分组, ROUND(:训练集准确率, 2), ROUND(: 验证集准确率, 2),
    ROUND(: 训练集损失值, 2), ROUND(: 验证集损失值, 2), ROUND(: 精确率, 2), ROUND(: 召回率, 2),
    ROUND(: F1值, 2),:混淆矩阵, ROUND(: AUC, 2))
    """

    # 插入数据
    cursor.execute(insert_sql, {
        "轮次": 1,
        "模型名称": model_name,
        "交叉验证分组": str(cv.get_n_splits()),
        "训练集准确率": train_accuracy,
        "验证集准确率": val_accuracy,
        "训练集损失值": train_loss,
        "验证集损失值": val_loss,
        "精确率": precision,
        "召回率": recall,
        "F1值": f1,
        "混淆矩阵": str(conf_matrix.tolist()) if conf_matrix is not None else None,
        "AUC": auc
    })

# 提交事务
connection.commit()

# 关闭连接
cursor.close()
connection.close()

print("所有模型的训练日志已插入数据库。")
